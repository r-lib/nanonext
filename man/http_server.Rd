% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/server.R
\name{http_server}
\alias{http_server}
\title{Create HTTP/WebSocket Server}
\usage{
http_server(
  url,
  handlers = list(),
  ws_path = "/",
  on_open = NULL,
  on_message = NULL,
  on_close = NULL,
  tls = NULL,
  textframes = FALSE
)
}
\arguments{
\item{url}{URL to listen on. Use "http://" or "https://" scheme.
Examples: "http://0.0.0.0:8080", "https://127.0.0.1:8443"}

\item{handlers}{List of HTTP handlers created with \code{\link[=handler]{handler()}}.}

\item{ws_path}{Path for WebSocket connections (default "/"). Only used
if WebSocket callbacks are provided.}

\item{on_open}{Function called when a WebSocket client connects.
Receives the connection object as its argument.}

\item{on_message}{Function called when a WebSocket message is received.
Receives the connection object and message data.}

\item{on_close}{Function called when a WebSocket client disconnects.
Receives the connection object.}

\item{tls}{TLS configuration for HTTPS/WSS, created via \code{\link[=tls_config]{tls_config()}}.}

\item{textframes}{[default FALSE] Logical, use WebSocket text frames.}
}
\value{
A nanoServer object with methods:
\itemize{
\item \code{$start()} - Start accepting connections
\item \code{$stop()} - Stop accepting new connections
\item \code{$close()} - Stop and release all resources
\item \code{$url} - The server URL
}
}
\description{
Creates an HTTP server that can handle both HTTP requests and WebSocket
connections on the same port. Supports HTTP, HTTPS, WS, and WSS.
}
\details{
This function leverages NNG's shared HTTP server architecture. When both
HTTP handlers and WebSocket callbacks are provided, they share the same
underlying server and port. The WebSocket listener automatically handles
the HTTP upgrade handshake and all WebSocket framing (RFC 6455).

WebSocket callbacks are executed on R's main thread via the 'later' package.
To process callbacks, you must run the event loop (e.g., using
\code{later::run_now()} in a loop).
}
\examples{
\dontshow{if (interactive() && requireNamespace("later", quietly = TRUE)) withAutoprint(\{ # examplesIf}
# Simple HTTP server
server <- http_server(
  url = "http://127.0.0.1:8080",
  handlers = list(
    handler("/", function(req) {
      list(status = 200L, body = "Hello, World!")
    }),
    handler("/api/data", function(req) {
      list(
        status = 200L,
        headers = c("Content-Type" = "application/json"),
        body = '{"value": 42}'
      )
    })
  )
)
server$start()
# Run event loop
# repeat later::run_now(Inf)
server$close()

# HTTP + WebSocket server
server <- http_server(
  url = "http://127.0.0.1:8443",
  handlers = list(
    handler("/", function(req) {
      list(status = 200L, body = "<html>...</html>")
    })
  ),
  ws_path = "/ws",
  on_open = function(ws) {
    cat("WebSocket connected:", ws$id, "\n")
  },
  on_message = function(ws, data) {
    cat("Received:", data, "\n")
    ws$send(data)
  },
  on_close = function(ws) {
    cat("WebSocket disconnected:", ws$id, "\n")
  },
  textframes = TRUE
)
server$start()
# Run event loop
# repeat later::run_now(Inf)
server$close()

# HTTPS server with self-signed certificate
cert <- write_cert(cn = "127.0.0.1")
server <- http_server(
  url = "https://127.0.0.1:8445",
  handlers = list(
    handler("/", function(req) list(status = 200L, body = "Hello, HTTPS!"))
  ),
  tls = tls_config(server = cert$server)
)
server$start()

# Send async request and run event loop
aio <- ncurl_aio(
  "https://127.0.0.1:8443/",
  tls = tls_config(client = cert$client),
  timeout = 2000
)
while (unresolved(aio)) later::run_now(0.1)

aio$status
aio$data

server$close()
\dontshow{\}) # examplesIf}
}
